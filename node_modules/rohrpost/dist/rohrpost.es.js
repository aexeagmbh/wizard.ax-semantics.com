import EventEmitter from 'events';

var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();









var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};











var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};

/* global WebSocket */
var defer = function defer() {
	var deferred = {};
	deferred.promise = new Promise(function (resolve, reject) {
		deferred.resolve = resolve;
		deferred.reject = reject;
	});
	return deferred;
};

var RohrpostClient = function (_EventEmitter) {
	inherits(RohrpostClient, _EventEmitter);

	function RohrpostClient(url, config) {
		classCallCheck(this, RohrpostClient);

		var _this = possibleConstructorReturn(this, (RohrpostClient.__proto__ || Object.getPrototypeOf(RohrpostClient)).call(this));

		var defaultConfig = {
			pingInterval: 5000,
			token: ''
		};
		_this.config = Object.assign(defaultConfig, config);
		_this._socket = new WebSocket(url);
		_this._pingState = {
			latestPong: 0
		};
		_this._socket.addEventListener('open', function () {
			_this.emit('open');
			// start pinging
			_this._ping();
		});

		_this._socket.addEventListener('close', function () {
			_this.emit('closed'); // why past tense? because the socket is already closed and not currently closing
		});

		_this._socket.addEventListener('message', _this._processMessage.bind(_this));
		_this._openRequests = {}; // save deferred promises from requests waiting for reponse
		_this._nextRequestIndex = 1; // autoincremented rohrpost message id
		return _this;
	}

	createClass(RohrpostClient, [{
		key: 'close',
		value: function close() {
			this._socket.close();
		}
	}, {
		key: 'subscribe',
		value: function subscribe(group) {
			var _createRequest2 = this._createRequest(),
			    id = _createRequest2.id,
			    promise = _createRequest2.promise;

			var payload = {
				type: 'subscribe',
				id: id,
				auth_jwt: this.config.token,
				data: group
			};
			this._socket.send(JSON.stringify(payload));
			return promise;
		}
	}, {
		key: 'unsubscribe',
		value: function unsubscribe(group) {
			// glorious copypasta
			var _createRequest3 = this._createRequest(),
			    id = _createRequest3.id,
			    promise = _createRequest3.promise;

			var payload = {
				type: 'unsubscribe',
				id: id,
				auth_jwt: this.config.token,
				data: group
			};
			this._socket.send(JSON.stringify(payload));
			return promise;
		}

		// ===========================================================================
		// INTERNALS
		// ===========================================================================

	}, {
		key: '_ping',
		value: function _ping() {
			var _this2 = this;

			if (this._socket.readyState !== 1) // socket still open?
				return;
			var timestamp = Date.now();
			var payload = {
				type: 'ping',
				id: timestamp
			};
			this._socket.send(JSON.stringify(payload));
			this.emit('ping');
			setTimeout(function () {
				if (timestamp > _this2._pingState.latestPong) // we received no pong after the last ping
					_this2._handlePingTimeout();else _this2._ping();
			}, this.config.pingInterval);
		}
	}, {
		key: '_handlePingTimeout',
		value: function _handlePingTimeout() {
			this._socket.close();
			this.emit('closed');
		}
	}, {
		key: '_processMessage',
		value: function _processMessage(rawMessage) {
			var message = JSON.parse(rawMessage.data);
			if (message.error) {
				// this.emit('error', message.error)
				this._popPendingRequest(message.id).reject(message.error);
				return;
			}
			this.emit('message', message);

			var typeHandlers = {
				pong: this._handlePong.bind(this),
				subscribe: this._handleSubscribe.bind(this),
				unsubscribe: this._handleUnsubscribe.bind(this),
				'subscription-update': this._handlePublish.bind(this)
			};

			if (typeHandlers[message.type] === undefined) {
				this.emit('error', 'incoming message type "' + message.type + '" not recognized');
			} else {
				typeHandlers[message.type](message);
			}
		}
	}, {
		key: '_handlePong',
		value: function _handlePong(message) {
			this.emit('pong');
			this._pingState.latestPong = Date.now();
		}
	}, {
		key: '_handleSubscribe',
		value: function _handleSubscribe(message) {
			var req = this._popPendingRequest(message.id);
			if (req === null) return; // error already emitted in pop
			req.resolve(message.data);
		}
	}, {
		key: '_handleUnsubscribe',
		value: function _handleUnsubscribe(message) {
			var req = this._popPendingRequest(message.id);
			if (req === null) return; // error already emitted in pop
			req.resolve(message.data);
		}
	}, {
		key: '_handlePublish',
		value: function _handlePublish(message) {
			this.emit(message.data.group, null, message.data);
		}

		// request - response promise matching

	}, {
		key: '_createRequest',
		value: function _createRequest() {
			var id = this._nextRequestIndex++;
			var deferred = defer();
			this._openRequests[id] = deferred;
			return { id: id, promise: deferred.promise };
		}
	}, {
		key: '_popPendingRequest',
		value: function _popPendingRequest(id) {
			var deferred = this._openRequests[id];
			if (!deferred) {
				this.emit('error', 'no saved request with id: ' + id);
			} else {
				this._openRequests[id] = undefined;
				return deferred;
			}
		}
	}]);
	return RohrpostClient;
}(EventEmitter);

export default RohrpostClient;
